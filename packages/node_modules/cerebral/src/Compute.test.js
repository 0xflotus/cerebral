/* eslint-env mocha */
import { Controller, Module, Compute } from './'
import { state, props } from './tags'
import assert from 'assert'

describe('Compute', () => {
  test('should Compute a value', () => {
    const computed = Compute(() => {
      return 'foo'
    })
    assert.equal(computed.getValue(), 'foo')
  })
  test('should pass get into function', () => {
    const computed = Compute((get) => {
      return get(state`foo`)
    })
    assert.equal(
      computed.getValue({
        state: {
          get() {
            return 'foo'
          },
        },
      }),
      'foo'
    )
  })
  test('should pass previous args into functions', () => {
    const computed = Compute('foo', (foo, get) => {
      return foo + get(props`foo`)
    })
    assert.equal(
      computed.getValue({
        props: {
          foo: 'foo',
        },
      }),
      'foofoo'
    )
  })
  test('should resolve tags', () => {
    const computed = Compute(state`foo`, (foo) => {
      return foo
    })
    assert.equal(
      computed.getValue({
        state: {
          get() {
            return 'foo'
          },
        },
      }),
      'foo'
    )
  })
  test('should allow computed as previous arg', () => {
    const computedA = Compute(() => {
      return 'foo'
    })
    const computedB = Compute(computedA, (computedAValue) => {
      return computedAValue
    })
    assert.equal(computedB.getValue(), 'foo')
  })
  test('should allow multiple functions', () => {
    const computed = Compute(
      () => {
        return 'foo'
      },
      'bar',
      (foo, bar) => {
        return foo + bar
      },
      (foobar) => {
        return foobar + 'baz'
      }
    )
    assert.equal(computed.getValue(), 'foobarbaz')
  })
  test('should be able to resolve in actions and override props', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: [
          ({ resolve }) => {
            assert.equal(
              resolve.value(computed, {
                props: {
                  path: 'foo',
                },
              }),
              'bar'
            )
          },
        ],
      },
    })
    const computed = Compute(props`path`, (path, get) => {
      return get(state`${path}`)
    })
    const controller = Controller(rootModule)
    controller.getSignal('test')({
      path: 'bar',
    })
  })
})
